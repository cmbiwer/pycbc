#! /usr/bin/env python
# Copyright (C) 2017 Christopher M. Biwer
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
"""Draws from distributions.
"""

import os
import argparse
import logging
import numpy
import pycbc
from pycbc import inference
from pycbc.workflow import WorkflowConfigParser

import glue
from glue.ligolw import ilwd
from glue.ligolw import ligolw
from glue.ligolw import lsctables
from glue.ligolw import utils
from pycbc.types import optparse
import sys

def convert_liststring_to_list(lstring):
    """ Checks if an argument of the configuration file is a string of a list
    and returns the corresponding list (of strings)
    """
    if lstring[0] == "[" and lstring[-1] == "]":
        lvalue = [str(lstring[1:-1].split(",")[n].strip().strip("'"))
                      for n in range(len(lstring[1:-1].split(",")))]
    return lvalue

# command line usage
parser = argparse.ArgumentParser(usage=__file__ + " [--options]",
                                 description=__doc__)

# add data options
parser.add_argument("--seed", type=int, default=0,
                    help="Random seed.")
parser.add_argument("--instruments", type=str, nargs="+", required=True,
                    help="IFOs, eg. H1 L1.")
parser.add_argument("--ninjections", type=int, default=0,
                    help="Number of injections to draw parameters.")

# add config options
parser.add_argument("--config-files", type=str, nargs="+", required=True,
                    help="A file parsable by "
                         "pycbc.workflow.WorkflowConfigParser.")
parser.add_argument("--config-overrides", type=str, nargs="+", default=None,
                    metavar="SECTION:OPTION:VALUE",
                    help="List of section:option:value combinations to add "
                         "into the configuration file.")

# output options
parser.add_argument("--output-file", type=str, required=True,
                    help="Output file path.")
parser.add_argument("--force", action="store_true", default=False,
                    help="If the output-file already exists, overwrite it. "
                         "Otherwise, an OSError is raised.")
 
# verbose option
parser.add_argument("--verbose", action="store_true", default=False,
                    help="Print logging messages.")

# parse command line
opts = parser.parse_args()

# check for the output file
if os.path.exists(opts.output_file) and not opts.force:
    raise OSError("output-file already exists; use --force if you wish to "
                  "overwrite it.")

# setup log
pycbc.init_logging(opts.verbose)

# set the seed
numpy.random.seed(opts.seed)
logging.info("Using seed %i", opts.seed)

# read configuration file
logging.info("Reading configuration file")
if opts.config_overrides is not None:
    overrides = [override.split(":") for override in opts.config_overrides]
else:
    overrides = None
cp = WorkflowConfigParser(opts.config_files, overrides)

# sanity check that each parameter in [variable_args] has a priors section
variable_args = cp.options("variable_args")
subsections = cp.get_subsections("prior")
tags = numpy.concatenate([tag.split("+") for tag in subsections])
if not any(param in tags for param in variable_args):
    raise KeyError("You are missing a priors section in the config file.")

# get parameters that do not change in sampler
static_args = dict([(key, cp.get_opt_tags("static_args", key, []))
                    for key in cp.options("static_args")])
for key, val in static_args.iteritems():
    try:
        static_args[key] = float(val)
        continue
    except:
        pass
    try:
        static_args[key] = convert_liststring_to_list(val) 
    except:
        pass

# get prior distribution for each variable parameter
logging.info("Setting up priors for each parameter")
dists = inference.read_distributions_from_config(cp, "prior")

# draw samples
logging.info("Drawing samples")
samples = {}
for dist in dists:
    dist_samples = dist.rvs(size=opts.ninjections)
    for param in dist.params:
        samples[param] = dist_samples[param]

print samples

def empty_sim_inspiral(i):
    """ Return empty SimInspiral.

    Returns
    --------
    lsctables.SimInspiral
        The "empty" SimInspiral object.
    """
    sim = lsctables.SimInspiral()
    cols = lsctables.SimInspiralTable.validcolumns
    for entry in cols.keys():
        if cols[entry] in ["real_4","real_8"]:
            setattr(sim,entry,0.)
        elif cols[entry] == "int_4s":
            setattr(sim,entry,0)
        elif cols[entry] == "lstring":
            setattr(sim,entry,"")
        elif entry == "process_id":
            sim.process_id = ilwd.ilwdchar("process:process_id:0")
        elif entry == "simulation_id":
            sim.simulation_id = ilwd.ilwdchar(
                                           "sim_inspiral:simulation_id:%d" % i)
        else:
            raise ValueError("Column %s not recognized" %(entry) )
    return sim

# create output XML file
logging.info('Creating XML file')
outdoc = ligolw.Document()
outdoc.appendChild(ligolw.LIGO_LW())

# put opts into a dict for the process table
opts_dict = optparse.convert_to_process_params_dict(opts)

# create process table
proc_id = utils.process.register_to_xmldoc(
                    outdoc, sys.argv[0], opts_dict,
                    comment="", ifos=["".join(opts.instruments)],
                    version=glue.git_version.id,
                    cvs_repository=glue.git_version.branch,
                    cvs_entry_time=glue.git_version.date).process_id

# create SimInspiral table
sim_table = lsctables.New(lsctables.SimInspiralTable,
                          columns=lsctables.SimInspiralTable.validcolumns)
outdoc.childNodes[0].appendChild(sim_table)

# loop over injections
for i in range(opts.ninjections):

    # get SimInspiral and set simulation_id
    sim = empty_sim_inspiral(i)

    # add value if it was in a Distribution
    for key in samples.keys():
        if hasattr(sim, key):
            setattr(sim, key, samples[key][i])
        else:
            logging.info("Ignored %s", key)

    # timing columns

    # mass columns

    # SNR scaling

    # append to SimInspiralTable
    sim_table.append(sim)

    # add static columns
    for key, val in static_args.iteritems():
        if hasattr(sim, key):
            setattr(sim, key, val)
        else:
            logging.info("Ignored %s", key)


# write XML file
logging.info("Writing file")
utils.write_filename(outdoc, opts.output_file,
                     gz=opts.output_file.endswith('gz'))

# SimInspiral
# 'alpha', 'alpha1', 'alpha2', 'alpha3', 'alpha4', 'alpha5', 'alpha6',
# 'amp_order', 'bandpass', 'beta',
# 'coa_phase', 'distance',
# 'eff_dist_g', 'eff_dist_h', 'eff_dist_l', 'eff_dist_t', 'eff_dist_v',
# 'end_time_gmst', 'eta', 'f_final', 'f_lower',
# 'g_end_time', 'g_end_time_ns', 'geocent_end_time', 'geocent_end_time_ns',
# 'h_end_time', 'h_end_time_ns',
# 'inclination', 'l_end_time', 'l_end_time_ns', 'latitude', 'longitude',
# 'mass1', 'mass2', 'mchirp', 'numrel_data', 'numrel_mode_max',
# 'numrel_mode_min', 'phi0', 'polarization', 'process_id', 'psi0', 'psi3',
# 'set_time_geocent', 'simulation_id', 'source', 'spin1x', 'spin1y',
# 'spin1z', 'spin2x', 'spin2y', 'spin2z', 't_end_time', 't_end_time_ns',
# 'taper', 'theta0', 'v_end_time', 'v_end_time_ns', 'waveform'

# exit
logging.info("Done")
