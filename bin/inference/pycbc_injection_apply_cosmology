#!/usr/bin/python

# Copyright (C) 2017 Christopher M. Biwer
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import argparse
import logging
import numpy
import os, sys
from glue.ligolw import ligolw, lsctables, table, utils
import pycbc
from pycbc import cosmology
from pycbc import pnutils
from pycbc.inference import prior
from pycbc.inject import InjectionSet, legacy_approximant_name
from pycbc.types import TimeSeries
from pycbc.waveform import get_td_waveform

class DefaultContentHandler(ligolw.LIGOLWContentHandler):
    pass
lsctables.use_in(DefaultContentHandler)

# command line usage
parser = argparse.ArgumentParser()

# add command line options
parser.add_argument('--input-file', type=str, required=True)
parser.add_argument('--output-file', type=str, required=True)
parser.add_argument('--max-total-mass', type=float, default=500)
parser.add_argument('--min-mchirp', type=float, default=1)
parser.add_argument('--max-mchirp', type=float, default=500)
parser.add_argument("--max-q", type=float, default=500)

# parse command line
opts = parser.parse_args()

# setup log
pycbc.init_logging()

# read in injection LIGOLW XML file
logging.info('Reading injection file')
injections = InjectionSet(opts.input_file)

# create output file
logging.info('Creating XML file')
outdoc = ligolw.Document()
outdoc.appendChild(ligolw.LIGO_LW())

# create sim_inspiral table
sim_table = lsctables.New(lsctables.SimInspiralTable,
                          columns=lsctables.SimInspiralTable.validcolumns)
outdoc.childNodes[0].appendChild(sim_table)

# loop over rows in sim_inspiral table
for sim in injections.table:

    redshift = cosmology.redshift(sim.distance)
    sim.alpha3 = redshift
#    sim.distance *= (1 + redshift)
    sim.mass1 *= (1 + redshift)
    sim.mass2 *= (1 + redshift)
    sim.mchirp, sim.eta = pnutils.mass1_mass2_to_mchirp_eta(sim.mass1, sim.mass2)

    params = {
        "mchirp" : sim.mchirp,
        "q" : float(sim.mass1) / sim.mass2,
        "spin1z" : sim.spin1z,
        "spin2z" : sim.spin2z,
        "mass1" : sim.mass1,
        "mass2" : sim.mass2,
    }
    if prior.cut(params):
        continue

    if sim.mass1 / (1 + redshift) + sim.mass2 / (1 + redshift) > opts.max_total_mass:
        continue

    if sim.mchirp / (1 + redshift) < opts.min_mchirp or sim.mchirp / (1 + redshift) > opts.max_mchirp:
        continue

    if sim.mass1 / sim.mass2 > opts.max_q:
        continue

    sim_table.append(sim)

# write
if len(sim_table):
    utils.write_filename(outdoc, opts.output_file, gz=opts.output_file.endswith('gz'))

# finish
logging.info('Done')
