#! /usr/bin/env python
""" Plots the mass range.
"""

import argparse
import logging
import matplotlib as mpl#; mpl.use("Agg")
import matplotlib.cm as cm
import matplotlib.pyplot as plt
import numpy
import pickle
import pycbc
from pycbc import conversions

# command line usage
parser = argparse.ArgumentParser(usage=__file__ + " [--options]",
                                 description=__doc__)
parser.add_argument("--input-file", type=str, required=True,
                    help="Input file.")
parser.add_argument("--output-file", type=str, required=True,
                    help="Path to output plot.")
parser.add_argument("--threshold", type=float, default=0.0)
parser.add_argument("--parameter",
                    choices=["mchirp_src", "mass1_src", "mass2_src",
                             "mchirp", "q",
                             "mass1", "mass2", "distance", "redshift",
                             "chi_eff", "spin1z", "spin2z", "inclination",
                             "coa_phase", "polarization"])
parser.add_argument("--plot-min", type=float, default=None)
parser.add_argument("--plot-max", type=float, default=None)
opts = parser.parse_args()

# set figure parameters
rcParams = {
    "text.usetex": True,
    "figure.dpi": 600,
    "font.size": 10,
    "figure.figsize": (3.375, 2.5),
    "axes.titlesize": 10,
    "axes.labelsize": 10,
    "xtick.labelsize": 8,
    "ytick.labelsize": 8,
    "legend.fontsize": 8,
}
mpl.rcParams.update(rcParams)

# get data from pickle
intervals, injected =  pickle.load(open(opts.input_file, "r"))

# add q
for inject in injected:
    inject["q"] = conversions.q_from_mass1_mass2(inject["mass1"],
                                                 inject["mass2"])

# get number of injections
n_injections = len(injected)

#cmap_name = "afmhot_r"
cmap_name = "jet"
my_cmap = cm.get_cmap(cmap_name)
norm = mpl.colors.Normalize(0, 35)

parameter = opts.parameter

for interval, inject in zip(intervals, injected):

    if abs((interval["mchirp_src_med"] - inject["mchirp_src"]) / inject["mchirp_src"]) < opts.threshold:
        alpha = 0.2
        zorder = 10
    else:
        alpha = 1.0
        zorder = 20

    color = my_cmap(norm(interval["snr_med"])) # returns an rgba value

    plt.errorbar([inject[parameter]],
                 [interval[parameter + "_med"]],
                 yerr=[[interval[parameter + "_med"] - interval[parameter + "_low"]],
                       [interval[parameter + "_high"] - interval[parameter + "_med"]]],
                 ecolor=color, zorder=zorder, alpha=alpha)
    plt.scatter(inject[parameter], interval[parameter + "_med"],
                c=interval["snr_med"], cmap=plt.get_cmap(cmap_name),
                vmin=0, vmax=35, zorder=zorder + 1, alpha=alpha, s=1)

# get min and max for plotting
y_max = numpy.array([intervals[i][parameter + "_high"] for i in range(n_injections)]).max()
y_min = numpy.array([intervals[i][parameter + "_low"] for i in range(n_injections)]).min()
x_max = numpy.array([injected[i][parameter] for i in range(n_injections)]).max()
x_min = numpy.array([injected[i][parameter] for i in range(n_injections)]).min()
plt_min = opts.plot_min if opts.plot_min is not None else min(0.9 * x_min, 1.1 * y_min)
plt_max = opts.plot_max if opts.plot_max is not None else max(0.9 * x_max, 1.1 * y_max)

equal_line = numpy.arange(plt_min, plt_max, (plt_max - plt_min) / 100.)
plt.plot(equal_line, equal_line, "--")

if parameter.startswith("mass1") or parameter.startswith("mass2"):
    plt.hlines([60, 130], [plt_min, plt_min], plt_max, "r",
               linestyle="dashed")

if opts.parameter == "mass1_src":
    y_label = r"$m_1^\mathrm{src}$"
elif opts.parameter == "mass2_src":
    y_label = r"$m_2^\mathrm{src}$"
else:
    y_label = opts.parameter

plt.subplots_adjust(left=0.2, right=0.9, top=0.9, bottom=0.2)
plt.ylabel(r"Recovered " + y_label)
plt.xlabel(r"Injected " + y_label)
plt.ylim(plt_min, plt_max)
plt.xlim(plt_min, plt_max)
plt.grid()
cbar = plt.colorbar()
cbar.set_label("Median SNR")

format = "eps" if opts.output_file.endswith(".eps") else None

plt.savefig(opts.output_file, bbox_inches="tight", format=format)
plt.close()

