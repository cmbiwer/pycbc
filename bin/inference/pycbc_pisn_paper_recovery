#! /usr/bin/env python

import argparse
import matplotlib as mpl#; mpl.use("Agg")
import matplotlib.colorbar as cbar
import matplotlib.cm as cm
import matplotlib.pyplot as plt
import numpy
import pickle
from pycbc import conversions
from pycbc import pisn
from pycbc.io import pisn_io
from pycbc.results import pisn_plot

# command line usage
parser = argparse.ArgumentParser(usage=__file__ + " [--options]",
                                 description=__doc__)
parser.add_argument("--input-files", nargs="+", type=str, required=True,
                    help="Input files.")
parser.add_argument("--output-file", type=str, required=True,
                    help="Path to output plot.")
parser.add_argument("--threshold", type=float, default=0.0)
parser.add_argument("--parameter",
                    choices=["mchirp_src", "mass1_src", "mass2_src",
                             "mchirp", "q",
                             "mass1", "mass2", "distance", "redshift",
                             "chi_eff", "spin1z", "spin2z", "inclination",
                             "coa_phase", "polarization"])
parser.add_argument("--region", choices=["inside", "low", "high"], default=None)
parser.add_argument("--plot-min", type=float, default=None)
parser.add_argument("--plot-max", type=float, default=None)
opts = parser.parse_args()

# set figure parameters
pisn_plot.set_pisn_rcparams()

# get data from pickle
intervals, injected =  pisn_io.read_pisn_files(opts.input_files)

# add q
for inject in injected:
    inject["q"] = conversions.q_from_mass1_mass2(inject["mass1"],
                                                 inject["mass2"])

# get number of injections
n_injections = len(injected)
print opts.input_files, "has", n_injections, "injections"

# set scale for colorbar
cmap_name = "afmhot_r"
cmap = cm.get_cmap(cmap_name)
norm = mpl.colors.Normalize(pisn_plot.snr_low, pisn_plot.snr_high)

# create figure
fig1 = plt.figure()
ax1 = fig1.add_subplot(111)

# loop over injections
for interval, inject in zip(intervals, injected):

    # determine if in region
    low = interval[opts.parameter + "_low"]
    med = interval[opts.parameter + "_med"]
    high = interval[opts.parameter + "_high"]
    if opts.region:
        in_region = pisn_plot.in_region(low, high, opts.region, opts.parameter, opts.parameter)
    else:
        in_region = True

    # get plot formating for region
    if in_region:
        zorder = 20
        color = cmap(norm(interval["snr_med"]))
    else:
        zorder = 10
        color = "gray"

    # plot
    ax1.errorbar([inject[opts.parameter]],
                 [med],
                 yerr=[[med - low], [high - med]],
                 ecolor=color, zorder=zorder)
    if in_region:
        ax1.scatter(inject[opts.parameter], med,
                    c=interval["snr_med"], cmap=cmap,
                    vmin=pisn_plot.snr_low, vmax=pisn_plot.snr_high,
                    zorder=zorder, s=1)


# get min and max for finding limits of the axes
y_max = numpy.array([intervals[i][opts.parameter + "_high"] for i in range(n_injections)]).max()
y_min = numpy.array([intervals[i][opts.parameter + "_low"] for i in range(n_injections)]).min()
x_max = numpy.array([injected[i][opts.parameter] for i in range(n_injections)]).max()
x_min = numpy.array([injected[i][opts.parameter] for i in range(n_injections)]).min()
plt_min = opts.plot_min if opts.plot_min is not None else min(0.9 * x_min, 1.1 * y_min)
plt_max = opts.plot_max if opts.plot_max is not None else max(0.9 * x_max, 1.1 * y_max)

# plot 1:1 ratio line
equal_line = numpy.arange(plt_min, plt_max, (plt_max - plt_min) / 100.)
ax1.plot(equal_line, equal_line, "--", zorder=100)

# add PISN mass gap values if plotting component masses
if opts.parameter.startswith("mass1") or opts.parameter.startswith("mass2"):
    ax1.hlines([pisn.pisn_low, pisn.pisn_high],
               [plt_min, plt_min], plt_max, "r",
               linestyle="dashed", zorder=99)

# get labels
if opts.parameter == "mass1_src":
    y_label = r"$m_1^\mathrm{src}$"
elif opts.parameter == "mass2_src":
    y_label = r"$m_2^\mathrm{src}$"
elif opts.parameter == "mass1":
    y_label = r"$m_1^\mathrm{det}$"
elif opts.parameter == "mass2":
    y_label = r"$m_2^\mathrm{det}$"
else:
    y_label = opts.parameter

# format plot
plt.subplots_adjust(left=0.2, right=0.9, top=0.9, bottom=0.2)
plt.ylabel(r"Recovered " + y_label)
plt.xlabel(r"Injected " + y_label)
plt.ylim(plt_min, plt_max)
plt.xlim(plt_min, plt_max)
plt.grid()
plt.minorticks_on()

# set ticks
n = 7
step = float(plt_max - plt_min) / n
ax1.yaxis.set_ticks(numpy.arange(plt_min, plt_max + step, step))
step = float(plt_max - plt_min) / n
ax1.xaxis.set_ticks(numpy.arange(plt_min, plt_max + step, step))

# add colorbar
cax, _ = cbar.make_axes(ax1)
cb2 = cbar.ColorbarBase(cax, cmap=cmap, norm=norm)
cb2.set_label("Median Network SNR")

# save
form = "eps" if opts.output_file.endswith(".eps") else None
plt.savefig(opts.output_file, bbox_inches="tight", format=form)
plt.close()

