#!/usr/bin/env python
import multiprocessing, argparse, numpy, pycbc, logging, cProfile
from pycbc import version, waveform, types, filter as pfilter, scheme, psd as pypsd, noise, vetoes
from pycbc.types import MultiDetOptionAction, zeros
from pycbc.fft import ifft, IFFT
from pycbc.filter import correlate, LiveBatchMatchedFilter
from pycbc import strain
import pycbc.events

parser = argparse.ArgumentParser()
parser.add_argument('--verbose', action='store_true')
parser.add_argument('--version', action='version', version=version.git_verbose_msg)
parser.add_argument('--bank-file', help="Template bank xml file")
parser.add_argument('--low-frequency-cutoff', help="low frequency cutoff", type=int)
parser.add_argument('--sample-rate', help="output sample rate", type=int)
parser.add_argument('--chisq-bins', help="Number of chisq bins")
parser.add_argument('--analysis-chunk', type=int,
                        help="Amount of data to produce triggers in a  block")
parser.add_argument('--snr-threshold', type=float)
parser.add_argument('--channel-name', action=MultiDetOptionAction, nargs='+')
parser.add_argument('--frame-src', action=MultiDetOptionAction, nargs='+')
parser.add_argument('--highpass-frequency', type=float,
                        help="Frequency to apply highpass filtering")
parser.add_argument('--highpass-reduction', type=float,
                        help="DB to reduce low frequencies")
parser.add_argument('--highpass-bandwidth', type=float,
                        help="Width of the highpass turnover region in Hz")
parser.add_argument('--psd-recalculate-every', type=int, default=1)
parser.add_argument('--psd-samples', type=int, 
                        help="Number of PSD segments to use in the rolling estimate")
parser.add_argument('--psd-segment-length', type=int, 
                        help="Length in seconds of each PSD segment")
parser.add_argument('--psd-inverse-length', type=float, 
                        help="Lenght in time for the equivelant FIR filter")
parser.add_argument('--start-time', type=int, default=0)
parser.add_argument('--end-time', type=int, default=numpy.inf)
parser.add_argument('--approximant')
scheme.insert_processing_option_group(parser)

args = parser.parse_args()
scheme.verify_processing_options(args, parser)
pycbc.init_logging(args.verbose)

ctx = scheme.from_cli(args)

sr = args.sample_rate
flow = args.low_frequency_cutoff

# Approximant guess of the total padding
valid_pad = args.analysis_chunk
total_pad = args.psd_segment_length * 2 + valid_pad
bank = waveform.LiveFilterBank(args.bank_file, flow, sr, total_pad,
                               approximant=args.approximant)

waveforms = list(bank)
lengths = numpy.array([1.0 / waveform.delta_f for waveform in waveforms])

ifos = args.channel_name.keys()

data_reader = {}
for ifo in ifos:
    data_reader[ifo] = pycbc.strain.StrainBuffer([args.frame_src[ifo]], 
                        '%s:%s' % (ifo, args.channel_name[ifo]),
                        args.start_time, 
                        max_buffer=lengths.max(),
                        sample_rate=args.sample_rate,
                        highpass_frequency=args.highpass_frequency,
                        highpass_reduction=args.highpass_reduction,
                        highpass_bandwidth=args.highpass_bandwidth,
                        psd_samples=args.psd_samples,
                        psd_segment_length=args.psd_segment_length,
                        psd_inverse_length=args.psd_inverse_length)

with ctx:
    mf = LiveBatchMatchedFilter(waveforms, args.snr_threshold, args.chisq_bins)

    # prime pump for testing
    for i in range(35):
        for ifo in ifos:
            data_reader[ifo].advance(valid_pad)
    for ifo in ifos:
        data_reader[ifo].recalculate_psd()

    pr = cProfile.Profile()
    pr.enable()

    # get more data
    while data_reader[data_reader.keys()[0]].end_time < args.end_time:
        logging.info('Conditioning Data')
        for ifo in ifos:
            data_reader[ifo].advance(valid_pad)
            
            print data_reader[ifo].start_time
            if i % args.psd_recalculate_every == 0:
                data_reader[ifo].recalculate_psd()     
 
            mf.set_data(data_reader[ifo])
            
            logging.info('Filtering: %s' % ifo)
        
            while 1:
                result = mf.process_batch()     
                if result is None: break
                
                s, c = result

# cluster coincs over bank, calculate FAR

# send report if above threshold
pr.dump_stats('log')
