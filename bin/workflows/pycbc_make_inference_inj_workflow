#!/bin/env python

# Copyright (C) 2017 Christopher M. Biwer, Alexander Harvey Nitz
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
""" Creates a DAX for a parameter estimation injection study.
"""

import argparse
import h5py
import logging
import os
import Pegasus.DAX3 as dax
import pycbc.workflow as wf
import pycbc.workflow.inference_followups as inffu
import pycbc.workflow.minifollowups as mini
import pycbc.workflow.pegasus_workflow as wdax
import pycbc.version
import socket
import sys
from pycbc_glue import segments
from pycbc import results
from pycbc.results import layout
from pycbc.types import MultiDetOptionAction
from pycbc.types import MultiDetOptionAppendAction
from pycbc.workflow import core
from pycbc.workflow import plotting
from pycbc.workflow import WorkflowConfigParser

def to_file(path, ifo=None):
    """ Takes a str and returns a pycbc.workflow.pegasus_workflow.File
    instance.
    """
    fil = wdax.File(os.path.basename(path))
    fil.ifo = ifo
    path = os.path.abspath(path)
    fil.PFN(path, "local")
    return fil

def symlink_path(f, path):
    """ Symlinks a path.
    """
    if f is None:
        return
    try:
        os.symlink(f.storage_path, os.path.join(path, f.name))
    except OSError:
        pass

# command line parser
parser = argparse.ArgumentParser(description=__doc__[1:])

# version option
parser.add_argument("--version", action="version",
                    version=pycbc.version.git_verbose_msg, 
                    help="Prints version information.")

# workflow options
parser.add_argument("--workflow-name", default="my_unamed_inference_run",
                    help="Name of the workflow to append in various places.")
parser.add_argument("--output-dir", default=None,
                    help="Path to output directory.")
parser.add_argument("--output-map", default="output.map",
                    help="Path to output map file.")
parser.add_argument("--output-file", required=True,
                    help="Path to DAX file.")

# input configuration file options
parser.add_argument("--inference-config-file", type=str, required=True,
                    help="workflow.WorkflowConfigParser parsable file with "
                         "proir information.")
parser.add_argument("--prior-section", type=str, default="prior",
                    help="Name of the section in inference configuration file "
                         "that contains priors.")

# input frame files
parser.add_argument("--frame-files", nargs="+", default=None,
                    action=MultiDetOptionAppendAction,
                    help="GWF frame files to use.")

# add option groups
wf.add_workflow_command_line_group(parser)

# parser command line
opts = parser.parse_args()

# log to terminal until we know where the path to log output file
log_format = "%(asctime)s:%(levelname)s : %(message)s"
logging.basicConfig(format=log_format, level=logging.INFO)

# create workflow and sub-workflows
container = wf.Workflow(opts, opts.workflow_name)
workflow = wf.Workflow(opts, opts.workflow_name + "-main")
finalize_workflow = wf.Workflow(opts, opts.workflow_name + "-finalization")

# sections for output HTML pages
rdir = layout.SectionNumber("results",
                            ["posteriors", "priors", "workflow"])

# make data output and results directories
wf.makedir(opts.output_dir)
wf.makedir(rdir.base)
wf.makedir(rdir["workflow"])

# create files for workflow log
log_file_txt = wf.File(workflow.ifos, "workflow-log", workflow.analysis_time,
                      extension=".txt", directory=rdir["workflow"])
log_file_html = wf.File(workflow.ifos, "WORKFLOW-LOG", workflow.analysis_time,
                        extension=".html", directory=rdir["workflow"])

# switch saving log to file
logging.basicConfig(format=log_format, level=logging.INFO,
                    filename=log_file_txt.storage_path, filemode="w")
log_file = logging.FileHandler(filename=log_file_txt.storage_path, mode="w")
log_file.setLevel(logging.INFO)
formatter = logging.Formatter(log_format)
log_file.setFormatter(formatter)
logging.getLogger("").addHandler(log_file)
logging.info("Created log file %s" % log_file_txt.storage_path)

# typecast str from command line to File instances
config_file = to_file(opts.inference_config_file)

# construct Executable for creating injections
create_injections_exe = wf.Executable(workflow.cp, "create_injections",
                                      ifos=workflow.ifos,
                                      out_dir=opts.output_dir)

# construct Executable for running sampler
inference_exe = wf.Executable(workflow.cp, "inference", ifos=workflow.ifos,
                              out_dir=opts.output_dir)

gps_start_time = 0
gps_end_time = 100

seconds_before_time = int(workflow.cp.get_opt_tags(
                                        "workflow-inference",
                                        "data-seconds-before-trigger", ""))
seconds_after_time = int(workflow.cp.get_opt_tags(
                                        "workflow-inference",
                                        "data-seconds-after-trigger", ""))

# get channel names
channel_names = {}
for ifo in workflow.ifos:
    channel_names[ifo] = workflow.cp.get_opt_tags(
                               "workflow", "%s-channel-name" % ifo.lower(), "")
channel_names_str = " ".join([key + ":" + val for key, val in \
                              channel_names.iteritems()])

# loop over number of injections
n_injections = int(workflow.cp.get_opt_tags(
                                "workflow-inference", "num-injections", ""))
inference_files = wf.FileList([])
post_files = wf.FileList([])
for i in range(n_injections):

    # make node for creating injections
#    node = create_injections_exe.create_node()
#    node.add_input_opt("--config-file", config_file)
#    analysis_time = segments.segment(gps_start_time, gps_end_time)
#    injection_file = node.new_output_file_opt(analysis_time, ".hdf",
#                                              "--output-file",
#                                              tags=[str(i)])
#    workflow += node

    # make node for running sampler
    node = inference_exe.create_node()
    node.add_opt("--seed", i)
    node.add_opt("--instruments", " ".join(workflow.ifos))
    node.add_opt("--gps-start-time", gps_start_time)
    node.add_opt("--gps-end-time", gps_end_time)
    node.add_opt("--channel-name", channel_names_str)
    node.add_input_opt("--config-file", config_file)
    analysis_time = segments.segment(gps_start_time, gps_end_time)
    inference_file = node.new_output_file_opt(analysis_time, ".hdf",
                                              "--output-file",
                                              tags=[str(i)])
    inference_files.append(inference_file)
    workflow += node

    # make nodes for plotting posteriors
    post_files += inffu.make_inference_posterior_plot(
                          workflow, inference_file, rdir["posteriors"],
                          analysis_seg=analysis_time,
                          tags=[str(i)])

layout.single_layout(rdir["posteriors"], post_files)

def make_inference_inj_plots(workflow, cp, inference_files, output_dir,
                             name="inference_recovery",
                             analysis_seg=None, tags=None):

    # default values
    tags = [] if tags is None else tags
    analysis_seg = workflow.analysis_time \
                       if analysis_seg is None else analysis_seg
    output_files = core.FileList([])

    # make the directory that will contain the output files
    core.makedir(output_dir)

    # make Executable for plotting the recovery plot
    plot_exe = plotting.PlotExecutable(
                      workflow.cp, name, ifos=workflow.ifos,
                      out_dir=output_dir, universe="local",
                      tags=tags)

    # add command line options
    for param in cp.options("variable_args"):
        node = plot_exe.create_node()
        node.add_input_list_opt("--input-file", inference_files)
        node.new_output_file_opt(analysis_seg, ".png", "--output-file")
        node.add_opt("--parameters", param)
        workflow += node
        output_files += node.output_files

    return output_files

# read inference configuration file
cp = WorkflowConfigParser([opts.inference_config_file])

inj_plots = make_inference_inj_plots(workflow, cp, inference_files, rdir.base)

layout.single_layout(rdir.base, inj_plots)

# create versioning HTML pages
results.create_versioning_page(rdir["workflow/version"], container.cp)

# create node for making HTML pages
wf.make_results_web_page(finalize_workflow,
                         os.path.join(os.getcwd(), rdir.base))

# add sub-workflows to workflow
container += workflow
container += finalize_workflow

# make finalize sub-workflow depend on main sub-workflow
dep = dax.Dependency(parent=workflow.as_job, child=finalize_workflow.as_job)
container._adag.addDependency(dep)

# write dax
container.save(filename=opts.output_file, output_map_path=opts.output_map)

# save workflow configuration file
base = rdir["workflow/configuration"]
wf.makedir(base)
wf_ini = workflow.save_config("workflow.ini", base, container.cp)
layout.single_layout(base, wf_ini)

# save prior configuration file
base = rdir["priors/configuration"]
wf.makedir(base)
prior_ini = workflow.save_config("priors.ini", base, cp)
layout.single_layout(base, prior_ini)

# close the log and flush to the html file
logging.shutdown()
with open (log_file_txt.storage_path, "r") as log_file:
    log_data = log_file.read()
log_str = """
<p>Workflow generation script created workflow in output directory: %s</p>
<p>Workflow name is: %s</p>
<p>Workflow generation script run on host: %s</p>
<pre>%s</pre>
""" % (os.getcwd(), opts.workflow_name, socket.gethostname(), log_data)
kwds = {"title" : "Workflow Generation Log",
        "caption" : "Log of the workflow script %s" % sys.argv[0],
        "cmd" : " ".join(sys.argv)}
results.save_fig_with_metadata(log_str, log_file_html.storage_path, **kwds)
layout.single_layout(rdir["workflow"], ([log_file_html]))
