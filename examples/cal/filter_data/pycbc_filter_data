#! /usr/bin/python

import argparse
import ctypes
import logging
import matplotlib.pyplot as plt
from glue import lal
from glue import segments
from pycbc import frame
from pycbc import types

import ROOT
ROOT.gSystem.Load('/usr/lib64/libdmtsigp.so')
ROOT.gSystem.Load('/usr/lib64/libgdsplot.so')
from foton import FilterFile, Filter

# parse command line
parser = argparse.ArgumentParser(usage='pycbc_calibrate_data [--options]',
                  description='Read the detector data and applies filters to calibrate the data.')
parser.add_argument("--gps-start-time", type=int, required=True,
                  help="Time to begin filtering input data.")
parser.add_argument("--gps-end-time", type=int, required=True,
                  help="Time to finish filtering input data.")
parser.add_argument("--frame-cache", type=str, required=True,
                  help="Path to frame cache that contains data.")
parser.add_argument("--filter-file", type=str, required=True,
                  help="Path to foton filter file to extract filterbanks.")
parser.add_argument("--channel-name", type=str, required=True,
                  help="Name of channel to filter.")
parser.add_argument("--swstat-name", type=str, required=True,
                  help="Name of SWSTAT channel for the filterbank.")
parser.add_argument("--filter-name", type=str, required=True,
                  help="Name of filter to use from the filterbank.")
opts = parser.parse_args()

# setup log
logging_level = logging.DEBUG
logging.basicConfig(format='%(asctime)s : %(message)s', level=logging_level)

# read frame cache
logging.info('Reading cache file...')
frame_cache = lal.Cache.fromfilenames([opts.frame_cache])
frame_filenames = [entry.path for entry in frame_cache]

# get channel data from frame files
logging.info('Reading frame files...')
data = frame.read_frame(frame_filenames, opts.channel_name, start_time=opts.gps_start_time, end_time=opts.gps_end_time)

# get filter files
logging.info('Reading filter file...')
filter_file = FilterFile(opts.filter_file)

def filter_data(data, frame_filenames, swstat_channel_name,
                filter_name, start_time, end_time):
    '''
    A naive function to determine if the filter was on at the time
    and then filter the data.

    This module just checks the first time in the SWSTAT channel
    to see if the filter was on, it doesn't check beyond that.

    This is just for a first test on a small chunck of data.
    '''

    # loop over bits that state if the filter was on or off
    swstat = frame.read_frame(frame_filenames, swstat_channel_name,
                      start_time=start_time, end_time=end_time)
    bits = bin(ctypes.c_int.from_buffer(ctypes.c_float(swstat[0])).value)[2:12]
    for i in range(10):

        # if bit is on then filter the data
        bit = int(bits[i])
        if bit:
            print 'filtering with...', bit, i, filter_name
            data = Filter(filter_file[filter_name][bit]).apply(data)

    return  data

# apply filters to DARM error
logging.info('Filtering '+opts.channel_name+'...')
data_filtered = filter_data(data, frame_filenames, opts.swstat_name, opts.filter_name,
                              data.start_time, data.start_time+data.duration)

del ROOT

# plot
logging.info('Plotting data...')
plt.plot(data.sample_times, data.numpy())
plt.plot(data.sample_times, data_filtered.numpy())

# exit
logging.info('Done.')
