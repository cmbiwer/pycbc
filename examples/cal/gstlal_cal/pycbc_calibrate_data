#! /usr/bin/python

import argparse
import ctypes
import logging
from glue import lal
from glue import segments
from pycbc import frame
from pycbc import types
from pycbc.filter.zpk import filter_zpk

import ROOT
ROOT.gSystem.Load('/usr/lib64/libdmtsigp.so')
ROOT.gSystem.Load('/usr/lib64/libgdsplot.so')
from foton import FilterFile, Filter

# parse command line
parser = argparse.ArgumentParser(usage='pycbc_calibrate_data [--options]',
                  description='Read the detector data and applies filters to calibrate the data.')
parser.add_argument("--gps-start-time", type=int, required=True,
                  help="Time to begin filtering input data.")
parser.add_argument("--gps-end-time", type=int, required=True,
                  help="Time to finish filtering input data.")
parser.add_argument("--frame-cache", type=str, required=True,
                  help="Path to frame cache that contains data.")
parser.add_argument("--filter-file", type=str, required=True,
                  help="Path to foton filter file to extract filterbanks.")
opts = parser.parse_args()

# initializations
channel_names = []
channel_names += ['L1:CAL-DARM_ERR_WHITEN_OUT_DQ']
channel_names += ['L1:CAL-DARM_CTRL_WHITEN_OUT_DQ']

# setup log
logging_level = logging.DEBUG
logging.basicConfig(format='%(asctime)s : %(message)s', level=logging_level)

# read frame cache
logging.info('Reading cache file...')
frame_cache = lal.Cache.fromfilenames([opts.frame_cache])
frame_filenames = [entry.path for entry in frame_cache]

# get channel data from frame files
logging.info('Reading frame files...')
data = frame.read_frame(frame_filenames, channel_names, start_time=opts.gps_start_time, end_time=opts.gps_end_time)

# get filter files
logging.info('Reading filter files...')
filter_file = FilterFile(opts.filter_file)

# put data into arrays
darm_in1 = filter_zpk(data[0], [100]*5, [1]*5, 1e-10)
darm_in1 = darm_in1.numpy()
darm_out = filter_zpk(data[1], [100]*5, [1]*5, 1e-10)
darm_out = darm_out.numpy()

def filter_data(data, frame_filenames, swstat_channel_name, bits,
                filter_name, start_time, end_time):
    '''
    A naive function to determine if the filter was on at the time
    and then filter the data.

    This module just checks the first time in the SWSTAT channel
    to see if the filter was on, it doesn't check beyond that.

    This is just for a first test on a small chunck of data.
    '''

    # loop over bits that state if the filter was on or off
#    swstat = frame.read_frame(frame_filenames, swstat_channel_name,
#                      start_time=start_time, end_time=end_time)
#    bits = bin(ctypes.c_int.from_buffer(ctypes.c_float(swstat[0])).value)[2:12]

    for i in range(10):

        print bits

        # if bit is on then filter the data
        bit = int(bits[i])
        if bit:
            print filter_name, Filter(filter_file[filter_name][i]).design.name, i, bit
            print Filter(filter_file[filter_name][i]).sections
            data = Filter(filter_file[filter_name][i]).apply(data)

    return  data

# apply filters to DARM error
logging.info('Filtering DARM error...')
darm_in1_timeseries = types.TimeSeries(darm_in1, delta_t=data[0].delta_t, epoch=data[0].start_time)
darm_in1_timeseries.save('output/darm_in1.txt')
darm_in1_err_filtered = filter_data(darm_in1, frame_filenames, 'L1:OAF-CAL_SUM_DARM_ERR_SWSTAT',
                                           '1000100001', 'CAL_SUM_DARM_ERR',
                                           data[0].start_time, data[0].start_time+data[0].duration)
darm_in1_err_filtered_timeseries = types.TimeSeries(darm_in1, delta_t=data[0].delta_t, epoch=data[0].start_time)
darm_in1_err_filtered_timeseries.save('output/darm_in1_err_filtered.txt')

# apply filters to DARM control
logging.info('Filtering DARM control...')
darm_out_l1_filtered = filter_data(darm_out, frame_filenames, 'L1:OAF-CAL_SUM_DARM_L1_SWSTAT',
                                           '1110011001', 'CAL_SUM_DARM_L1',
                                           data[0].start_time, data[0].start_time+data[0].duration)
darm_out_l2_filtered = filter_data(darm_out, frame_filenames, 'L1:OAF-CAL_SUM_DARM_L2_SWSTAT',
                                           '0000011101', 'CAL_SUM_DARM_L2',
                                           data[0].start_time, data[0].start_time+data[0].duration)
darm_out_l3_filtered = filter_data(darm_out, frame_filenames, 'L1:OAF-CAL_SUM_DARM_L3_SWSTAT',
                                           '1110010101', 'CAL_SUM_DARM_L3',
                                           data[0].start_time, data[0].start_time+data[0].duration)
darm_out_m0_filtered = filter_data(darm_out, frame_filenames, 'L1:OAF-CAL_SUM_DARM_M0_SWSTAT',
                                           '1100000001', 'CAL_SUM_DARM_M0',
                                           data[0].start_time, data[0].start_time+data[0].duration)

# sum filtered DARM control
logging.info('Summing filtered DARM control...')
sum_darm_out_filtered = 1.0*darm_out_m0_filtered + 0.7*darm_out_l1_filtered + 2.4*darm_out_l2_filtered + 1.34*darm_out_l3_filtered

# sum filtered error and filtered control
logging.info('Summing filtered DARM control and filtered error...')
sum_darm_filtered = sum_darm_out_filtered + 0.63*darm_in1_err_filtered

# write output
logging.info('Writing data...')
output_data = types.TimeSeries(sum_darm_filtered, delta_t=data[0].delta_t, epoch=data[0].start_time)
output_data.save('output/test.txt')

# exit
logging.info('Done.')
